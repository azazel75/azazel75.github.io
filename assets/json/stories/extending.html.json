{"lang": "en", "permalink": "/stories/extending.html", "description": "", "title": "Extending Nikola", "template_name": "story.tmpl", "enable_comments": false, "post": {"prev_post": null, "permalink": "/stories/extending.html", "id_comments": "cache/stories/extending.html", "text_stripped": "Extending Nikola\n\n\n\n\nVersion:7.1.0\n\nAuthor:Roberto Alsina <ralsina@netmanagers.com.ar>\n\n\n\n\nContents\n\nExtending Nikola\nCommand Plugins\nTemplateSystem Plugins\nTask Plugins\nPageCompiler Plugins\nRestExtension Plugins\nMarkdownExtension Plugins\nSignalHandler Plugins\n\n\nPlugin Index\nPath/Link Resolution Mechanism\nTemplate Hooks\n\n\nNikola is extensible. Almost all its functionality is based on plugins,\nand you can add your own or replace the provided ones.\nPlugins consist of a metadata file (with .plugin extension) and\na Python module (a .py file) or package (a folder containing\na __init__.py file.\nTo use a plugin in your site, you just have to put it in a plugins\nfolder in your site.\nPlugins come in various flavours, aimed at extending different aspects\nof Nikola.\n\nCommand Plugins\nWhen you run nikola --help you will see something like this:\n\n$ nikola help\nNikola is a tool to create static websites and blogs. For full documentation and more\ninformation, please visit http://getnikola.com\n\n\nAvailable commands:\nnikola auto                 automatically detect site changes, rebuild\n                            and optionally refresh a browser\nnikola bootswatch_theme     given a swatch name from bootswatch.com and a\n                            parent theme, creates a custom theme\nnikola build                run tasks\nnikola check                check links and files in the generated site\nnikola clean                clean action / remove targets\nnikola console              start an interactive python console with access to\n                            your site and configuration\nnikola deploy               deploy the site\nnikola dumpdb               dump dependency DB\nnikola forget               clear successful run status from internal DB\nnikola help                 show help\nnikola ignore               ignore task (skip) on subsequent runs\nnikola import_blogger       import a blogger dump\nnikola import_feed          import a RSS/Atom dump\nnikola import_wordpress     import a WordPress dump\nnikola init                 create a Nikola site in the specified folder\nnikola install_theme        install theme into current site\nnikola list                 list tasks from dodo file\nnikola mincss               apply mincss to the generated site\nnikola new_post             create a new blog post or site page\nnikola run                  run tasks\nnikola serve                start the test webserver\nnikola strace               use strace to list file_deps and targets\nnikola version              print the Nikola version number\n\nnikola help                 show help / reference\nnikola help <command>       show command usage\nnikola help <task-name>     show task usage\n\nThat will give you a list of all available commands in your version of Nikola.\nEach and every one of those is a plugin. Let's look at a typical example:\nFirst, the serve.plugin file:\n\n[Core]\nName = serve\nModule = serve\n\n[Documentation]\nAuthor = Roberto Alsina\nVersion = 0.1\nWebsite = http://getnikola.com\nDescription = Start test server.\n\n\nNote\nIf you want to publish your plugin on the Plugin Index, read\nthe docs for the Index\n(and the .plugin file examples and explanations).\n\nFor your own plugin, just change the values in a sensible way. The\nModule will be used to find the matching Python module, in this case\nserve.py, from which this is the interesting bit:\n\nfrom nikola.plugin_categories import Command\n\n# You have to inherit Command for this to be a\n# command plugin:\n\nclass CommandServe(Command):\n    \"\"\"Start test server.\"\"\"\n\n    name = \"serve\"\n    doc_usage = \"[options]\"\n    doc_purpose = \"start the test webserver\"\n\n    cmd_options = (\n        {\n            'name': 'port',\n            'short': 'p',\n            'long': 'port',\n            'default': 8000,\n            'type': int,\n            'help': 'Port nummber (default: 8000)',\n        },\n        {\n            'name': 'address',\n            'short': 'a',\n            'long': '--address',\n            'type': str,\n            'default': '127.0.0.1',\n            'help': 'Address to bind (default: 127.0.0.1)',\n        },\n    )\n\n    def _execute(self, options, args):\n        \"\"\"Start test server.\"\"\"\n        out_dir = self.site.config['OUTPUT_FOLDER']\n        if not os.path.isdir(out_dir):\n            print(\"Error: Missing '{0}' folder?\".format(out_dir))\n        else:\n            os.chdir(out_dir)\n            httpd = HTTPServer((options['address'], options['port']),\n                            OurHTTPRequestHandler)\n            sa = httpd.socket.getsockname()\n            print(\"Serving HTTP on\", sa[0], \"port\", sa[1], \"...\")\n            httpd.serve_forever()\n\nAs mentioned above, a plugin can have options, which the user can see by doing\nnikola help command and can later use, for example:\n\n$ nikola help serve\nPurpose: start the test webserver\nUsage:   nikola serve [options]\n\nOptions:\n-p ARG, --port=ARG        Port nummber (default: 8000)\n-a ARG, ----address=ARG   Address to bind (default: 127.0.0.1)\n\n$ nikola serve -p 9000\nServing HTTP on 127.0.0.1 port 9000 ...\n\nSo, what can you do with commands? Well, anything you want, really. I have implemented\na sort of planet using it. So, be creative, and if you do something interesting,\nlet me know ;-)\n\n\nTemplateSystem Plugins\nNikola supports Mako and Jinja2. If you prefer some other templating\nsystem, then you will have to write a TemplateSystem plugin. Here's how they work.\nFirst, you have to create a .plugin file. Here's the one for the Mako plugin:\n\n[Core]\nName = mako\nModule = mako\n\n[Documentation]\nAuthor = Roberto Alsina\nVersion = 0.1\nWebsite = http://getnikola.com\nDescription = Support for Mako templates.\n\n\nNote\nIf you want to publish your plugin on the Plugin Index, read\nthe docs for the Index\n(and the .plugin file examples and explanations).\n\nYou will have to replace \"mako\" with your template system's name, and other data\nin the obvious ways.\nThe \"Module\" option is the name of the module, which has to look something like this,\na stub for a hypothetical system called \"Templater\":\n\nfrom nikola.plugin_categories import TemplateSystem\n\n# You have to inherit TemplateSystem\n\nclass TemplaterTemplates(TemplateSystem):\n    \"\"\"Wrapper for Templater templates.\"\"\"\n\n    # name has to match Name in the .plugin file\n    name = \"templater\"\n\n    # You *must* implement this, even if to return []\n    # It should return a list of all the files that,\n    # when changed, may affect the template's output.\n    # usually this involves template inheritance and\n    # inclusion.\n    def get_deps(self, filename):\n        return []\n\n    # A list of directories where the templates will be\n    # located. Most template systems have some sort of\n    # template loading tool that can use this.\n\n    def set_directories(self, directories):\n        \"\"\"Create a template lookup.\"\"\"\n        pass\n\n    # The method that does the actual rendering.\n    # template_name is the name of the template file,\n    # output_name is the file for the output, context\n    # is a dictionary containing the data the template\n    # uses for rendering.\n\n    def render_template(self, template_name, output_name,\n        context, global_context):\n        \"\"\"Render the template into output_name using context.\"\"\"\n        pass\n\n\n\nTask Plugins\nIf you want to do something that depends on the data in your site, you\nprobably want to do a Task plugin, which will make it be part of the\nnikola build command. There are the currently available tasks, all\nprovided by plugins:\n\nOther Tasks\nThere are also LateTask plugins, which are executed later,\nand TaskMultiplier plugins that take a task and create\nmore tasks out of it.\n\n\n$ nikola list\nScanning posts....done!\nbuild_bundles\nbuild_less\ncopy_assets\ncopy_files\npost_render\nredirect\nrender_archive\nrender_galleries\nrender_galleries_clean\nrender_indexes\nrender_listings\nrender_pages\nrender_posts\nrender_rss\nrender_site\nrender_sources\nrender_tags\nsitemap\n\nThese have access to the site object which contains your timeline and\nyour configuration.\nThe critical bit of Task plugins is their gen_tasks method, which yields\ndoit tasks.\nThe details of how to handle dependencies, etc., are a bit too much for this\ndocument, so I'll just leave you with an example, the copy_assets task.\nFirst the task_copy_assets.plugin file, which you should copy and edit\nin the logical ways:\n\n[Core]\nName = copy_assets\nModule = task_copy_assets\n\n[Documentation]\nAuthor = Roberto Alsina\nVersion = 0.1\nWebsite = http://getnikola.com\nDescription = Copy theme assets into output.\n\n\nNote\nIf you want to publish your plugin on the Plugin Index, read\nthe docs for the Index\n(and the .plugin file examples and explanations).\n\nAnd the task_copy_assets.py file, in its entirety:\n\nimport os\n\nfrom nikola.plugin_categories import Task\nfrom nikola import utils\n\n# Have to inherit Task to be a task plugin\nclass CopyAssets(Task):\n    \"\"\"Copy theme assets into output.\"\"\"\n\n    name = \"copy_assets\"\n\n    # This yields the tasks\n    def gen_tasks(self):\n        \"\"\"Create tasks to copy the assets of the whole theme chain.\n\n        If a file is present on two themes, use the version\n        from the \"youngest\" theme.\n        \"\"\"\n\n        # I put all the configurations and data the plugin uses\n        # in a dictionary because utils.config_changed will\n        # make it so that if these change, this task will be\n        # marked out of date, and run again.\n\n        kw = {\n            \"themes\": self.site.THEMES,\n            \"output_folder\": self.site.config['OUTPUT_FOLDER'],\n            \"filters\": self.site.config['FILTERS'],\n        }\n\n        tasks = {}\n        for theme_name in kw['themes']:\n            src = os.path.join(utils.get_theme_path(theme_name), 'assets')\n            dst = os.path.join(kw['output_folder'], 'assets')\n            for task in utils.copy_tree(src, dst):\n                if task['name'] in tasks:\n                    continue\n                tasks[task['name']] = task\n                task['uptodate'] = task.get('uptodate', []) + \\\n                    [utils.config_changed(kw)]\n                task['basename'] = self.name\n                # If your task generates files, please do this.\n                yield utils.apply_filters(task, kw['filters'])\n\n\n\nPageCompiler Plugins\nThese plugins implement markup languages, they take sources for posts or pages and\ncreate HTML or other output files. A good example is the misaka plugin.\nThey must provide:\n\ncompile_html\nFunction that builds a file.\ncreate_post\nFunction that creates an empty file with some metadata in it.\n\nIf the compiler produces something other than HTML files, it should also implement extension which\nreturns the preferred extension for the output file.\n\n\nRestExtension Plugins\nImplement directives for reStructuredText, see media.py for a simple example.\n\n\nMarkdownExtension Plugins\nImplement Markdown extensions, see mdx_nikola.py for a simple example.\n\n\nSignalHandler Plugins\nThese plugins extend the SignalHandler class and connect to one or more\nsignals via blinker.\nThe easiest way to do this is to reimplement set_site() and just connect to\nwhatever signals you want there.\nCurrently Nikola emits the following signals:\n\nsighandlers_loaded\nRight after SignalHandler plugin activation.\ninitialized\nWhen all tasks are loaded.\nconfigured\nWhen all the configuration file is processed. Note that plugins are activated before this is emitted.\nscanned\nAfter posts are scanned.\nnew_post\nWhen a new post is created, using the nikola new_post command.  The signal\ndata contains the path of the file, and the metadata file (if there is one).\ndeployed\nWhen the nikola deploy command is run, and there is at least one new\nentry/post since last_deploy.  The signal data is of the form:\n\n{\n 'last_deploy: # datetime object for the last deployed time,\n 'new_deploy': # datetime object for the current deployed time,\n 'clean': # whether there was a record of a last deployment,\n 'deployed': # all files deployed after the last deploy,\n 'undeployed': # all files not deployed since they are either future posts/drafts\n}\n\n\n\n\n\n\nPlugin Index\nThere is a plugin index, which stores all\nof the plugins for Nikola people wanted to share with the world.\nYou may want to read the README for the Index if you want to\npublish your package there.\n\n\nPath/Link Resolution Mechanism\nAny plugin can register a function using Nikola.register_path_handler to\nallow resolution of paths and links. These are useful for templates, which\ncan access them via _link.\nFor example, you can always get a link to the path for the feed of the \"foo\" tag\nby using _link('tag_rss', 'foo') or the link://tag_rss/foo URL.\nHere's the relevant code from the tag plugin.\n\n# In set_site\nsite.register_path_handler('tag_rss', self.tag_rss_path)\n\n# And these always take name and lang as arguments and returl a list of\n# path elements.\ndef tag_rss_path(self, name, lang):\n    return [_f for _f in [self.site.config['TRANSLATIONS'][lang],\n                          self.site.config['TAG_PATH'], self.slugify_name(name) + \".xml\"] if\n            _f]\n\n\n\nTemplate Hooks\nPlugins can use a hook system for adding stuff into templates.  In order to use\nit, a plugin must register itself.  The following hooks currently exist:\n\nextra_head (not equal to the config option!)\nbody_end (not equal to the config option!)\npage_header\nmenu\nmenu_alt (right-side menu in bootstrap, after menu in base)\npage_footer\n\nFor example, in order to register a script into extra_head:\n\n# In set_site\nsite.template_hooks['extra_head'].append('<script src=\"/assets/js/fancyplugin.js\">')\n\nThere is also another API available.  It allows use of dynamically generated\nHTML:\n\n# In set_site\ndef generate_html_bit(name, ftype='js'):\n    return '<script src=\"/assets/{t}/{n}.{t}\">'.format(n=name, t=ftype)\n\nsite.template_hooks['extra_head'].append(generate_html_bit, False, 'fancyplugin', type='js')\n\nThe second argument to append() is used to determine whether the function\nneeds access to the current template context and the site.  If it it set to\nTrue, the function will also receive site and context keyword\narguments.  Example use:\n\n# In set_site\ndef greeting(addr, endswith='', site=None, context=None):\n    if context['lang'] == 'en':\n        greet = u'Hello'\n    elif context['lang'] == 'es':\n        greet = u'¡Hola'\n\n    t = u' BLOG_TITLE = {0}'.format(site.config['BLOG_TITLE'](context['lang']))\n\n    return u'<h3>{greet} {addr}{endswith}</h3>'.format(greet=greet, addr=addr,\n    endswith=endswith) + t\n\nsite.template_hooks['page_header'].append(greeting, True, u'Nikola Tesla', endswith=u'!')", "abs_permalink": "http://getnikola.com/stories/extending.html", "formatted_date": "2012-03-30 23:00", "enable_comments": false, "author": "Nikola Tesla", "use_in_feeds": false, "translated_to": [], "is_mathjax": false, "meta": {"description": "", "tags": "", "title": "Extending Nikola", "annotations": "", "keywords": "", "author": "", "template": "", "date": "2012-03-30 23:00:00 UTC-03:00", "password": "", "type": "text", "slug": "extending"}, "text": "<div><div class=\"section\" id=\"extending-nikola\">\n<h2><a class=\"toc-backref\" href=\"/stories/extending.html#id1\">Extending Nikola</a></h2>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\">\n<col class=\"field-body\">\n<tbody valign=\"top\">\n<tr class=\"field\"><th class=\"field-name\">Version:</th><td class=\"field-body\">7.1.0</td>\n</tr>\n<tr class=\"field\"><th class=\"field-name\">Author:</th><td class=\"field-body\">Roberto Alsina &lt;<a class=\"reference external\" href=\"mailto:ralsina@netmanagers.com.ar\">ralsina@netmanagers.com.ar</a>&gt;</td>\n</tr>\n</tbody>\n</table>\n<div class=\"contents alert alert-info pull-right topic\" id=\"contents\">\n<p class=\"topic-title first\">Contents</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"/stories/extending.html#extending-nikola\" id=\"id1\">Extending Nikola</a><ul>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#command-plugins\" id=\"id2\">Command Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#templatesystem-plugins\" id=\"id3\">TemplateSystem Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#task-plugins\" id=\"id4\">Task Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#pagecompiler-plugins\" id=\"id5\">PageCompiler Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#restextension-plugins\" id=\"id6\">RestExtension Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#markdownextension-plugins\" id=\"id7\">MarkdownExtension Plugins</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#signalhandler-plugins\" id=\"id8\">SignalHandler Plugins</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#plugin-index\" id=\"id9\">Plugin Index</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#path-link-resolution-mechanism\" id=\"id10\">Path/Link Resolution Mechanism</a></li>\n<li><a class=\"reference internal\" href=\"/stories/extending.html#template-hooks\" id=\"id11\">Template Hooks</a></li>\n</ul>\n</div>\n<p class=\"lead\">Nikola is extensible. Almost all its functionality is based on plugins,\nand you can add your own or replace the provided ones.</p>\n<p>Plugins consist of a metadata file (with <tt class=\"docutils literal\">.plugin</tt> extension) and\na Python module (a <tt class=\"docutils literal\">.py</tt> file) or package (a folder containing\na <tt class=\"docutils literal\">__init__.py</tt> file.</p>\n<p>To use a plugin in your site, you just have to put it in a <tt class=\"docutils literal\">plugins</tt>\nfolder in your site.</p>\n<p>Plugins come in various flavours, aimed at extending different aspects\nof Nikola.</p>\n<div class=\"section\" id=\"command-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id2\">Command Plugins</a></h3>\n<p>When you run <tt class=\"docutils literal\">nikola <span class=\"pre\">--help</span></tt> you will see something like this:</p>\n<pre class=\"literal-block\">\n$ nikola help\nNikola is a tool to create static websites and blogs. For full documentation and more\ninformation, please visit http://getnikola.com\n\n\nAvailable commands:\nnikola auto                 automatically detect site changes, rebuild\n                            and optionally refresh a browser\nnikola bootswatch_theme     given a swatch name from bootswatch.com and a\n                            parent theme, creates a custom theme\nnikola build                run tasks\nnikola check                check links and files in the generated site\nnikola clean                clean action / remove targets\nnikola console              start an interactive python console with access to\n                            your site and configuration\nnikola deploy               deploy the site\nnikola dumpdb               dump dependency DB\nnikola forget               clear successful run status from internal DB\nnikola help                 show help\nnikola ignore               ignore task (skip) on subsequent runs\nnikola import_blogger       import a blogger dump\nnikola import_feed          import a RSS/Atom dump\nnikola import_wordpress     import a WordPress dump\nnikola init                 create a Nikola site in the specified folder\nnikola install_theme        install theme into current site\nnikola list                 list tasks from dodo file\nnikola mincss               apply mincss to the generated site\nnikola new_post             create a new blog post or site page\nnikola run                  run tasks\nnikola serve                start the test webserver\nnikola strace               use strace to list file_deps and targets\nnikola version              print the Nikola version number\n\nnikola help                 show help / reference\nnikola help &lt;command&gt;       show command usage\nnikola help &lt;task-name&gt;     show task usage\n</pre>\n<p>That will give you a list of all available commands in your version of Nikola.\nEach and every one of those is a plugin. Let's look at a typical example:</p>\n<p>First, the <tt class=\"docutils literal\">serve.plugin</tt> file:</p>\n<pre class=\"code ini literal-block\">\n<span class=\"k\">[Core]</span>\n<span class=\"na\">Name</span> <span class=\"o\">=</span> <span class=\"s\">serve</span>\n<span class=\"na\">Module</span> <span class=\"o\">=</span> <span class=\"s\">serve</span>\n\n<span class=\"k\">[Documentation]</span>\n<span class=\"na\">Author</span> <span class=\"o\">=</span> <span class=\"s\">Roberto Alsina</span>\n<span class=\"na\">Version</span> <span class=\"o\">=</span> <span class=\"s\">0.1</span>\n<span class=\"na\">Website</span> <span class=\"o\">=</span> <span class=\"s\">http://getnikola.com</span>\n<span class=\"na\">Description</span> <span class=\"o\">=</span> <span class=\"s\">Start test server.</span>\n</pre>\n<div class=\"note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">If you want to publish your plugin on the Plugin Index, <a class=\"reference external\" href=\"https://github.com/getnikola/plugins/blob/master/README.md\">read\nthe docs for the Index</a>\n(and the .plugin file examples and explanations).</p>\n</div>\n<p>For your own plugin, just change the values in a sensible way. The\n<tt class=\"docutils literal\">Module</tt> will be used to find the matching Python module, in this case\n<tt class=\"docutils literal\">serve.py</tt>, from which this is the interesting bit:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span> <span class=\"nn\">nikola.plugin_categories</span> <span class=\"kn\">import</span> <span class=\"n\">Command</span>\n\n<span class=\"c\"># You have to inherit Command for this to be a</span>\n<span class=\"c\"># command plugin:</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">CommandServe</span><span class=\"p\">(</span><span class=\"n\">Command</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Start test server.\"\"\"</span>\n\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"serve\"</span>\n    <span class=\"n\">doc_usage</span> <span class=\"o\">=</span> <span class=\"s\">\"[options]\"</span>\n    <span class=\"n\">doc_purpose</span> <span class=\"o\">=</span> <span class=\"s\">\"start the test webserver\"</span>\n\n    <span class=\"n\">cmd_options</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n        <span class=\"p\">{</span>\n            <span class=\"s\">'name'</span><span class=\"p\">:</span> <span class=\"s\">'port'</span><span class=\"p\">,</span>\n            <span class=\"s\">'short'</span><span class=\"p\">:</span> <span class=\"s\">'p'</span><span class=\"p\">,</span>\n            <span class=\"s\">'long'</span><span class=\"p\">:</span> <span class=\"s\">'port'</span><span class=\"p\">,</span>\n            <span class=\"s\">'default'</span><span class=\"p\">:</span> <span class=\"mi\">8000</span><span class=\"p\">,</span>\n            <span class=\"s\">'type'</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span>\n            <span class=\"s\">'help'</span><span class=\"p\">:</span> <span class=\"s\">'Port nummber (default: 8000)'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"s\">'name'</span><span class=\"p\">:</span> <span class=\"s\">'address'</span><span class=\"p\">,</span>\n            <span class=\"s\">'short'</span><span class=\"p\">:</span> <span class=\"s\">'a'</span><span class=\"p\">,</span>\n            <span class=\"s\">'long'</span><span class=\"p\">:</span> <span class=\"s\">'--address'</span><span class=\"p\">,</span>\n            <span class=\"s\">'type'</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span>\n            <span class=\"s\">'default'</span><span class=\"p\">:</span> <span class=\"s\">'127.0.0.1'</span><span class=\"p\">,</span>\n            <span class=\"s\">'help'</span><span class=\"p\">:</span> <span class=\"s\">'Address to bind (default: 127.0.0.1)'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_execute</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">options</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Start test server.\"\"\"</span>\n        <span class=\"n\">out_dir</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'OUTPUT_FOLDER'</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">isdir</span><span class=\"p\">(</span><span class=\"n\">out_dir</span><span class=\"p\">):</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Error: Missing '{0}' folder?\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">out_dir</span><span class=\"p\">))</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">chdir</span><span class=\"p\">(</span><span class=\"n\">out_dir</span><span class=\"p\">)</span>\n            <span class=\"n\">httpd</span> <span class=\"o\">=</span> <span class=\"n\">HTTPServer</span><span class=\"p\">((</span><span class=\"n\">options</span><span class=\"p\">[</span><span class=\"s\">'address'</span><span class=\"p\">],</span> <span class=\"n\">options</span><span class=\"p\">[</span><span class=\"s\">'port'</span><span class=\"p\">]),</span>\n                            <span class=\"n\">OurHTTPRequestHandler</span><span class=\"p\">)</span>\n            <span class=\"n\">sa</span> <span class=\"o\">=</span> <span class=\"n\">httpd</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">getsockname</span><span class=\"p\">()</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Serving HTTP on\"</span><span class=\"p\">,</span> <span class=\"n\">sa</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"s\">\"port\"</span><span class=\"p\">,</span> <span class=\"n\">sa</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">\"...\"</span><span class=\"p\">)</span>\n            <span class=\"n\">httpd</span><span class=\"o\">.</span><span class=\"n\">serve_forever</span><span class=\"p\">()</span>\n</pre>\n<p>As mentioned above, a plugin can have options, which the user can see by doing\n<tt class=\"docutils literal\">nikola help command</tt> and can later use, for example:</p>\n<pre class=\"literal-block\">\n$ nikola help serve\nPurpose: start the test webserver\nUsage:   nikola serve [options]\n\nOptions:\n-p ARG, --port=ARG        Port nummber (default: 8000)\n-a ARG, ----address=ARG   Address to bind (default: 127.0.0.1)\n\n$ nikola serve -p 9000\nServing HTTP on 127.0.0.1 port 9000 ...\n</pre>\n<p>So, what can you do with commands? Well, anything you want, really. I have implemented\na sort of planet using it. So, be creative, and if you do something interesting,\nlet me know ;-)</p>\n</div>\n<div class=\"section\" id=\"templatesystem-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id3\">TemplateSystem Plugins</a></h3>\n<p>Nikola supports Mako and Jinja2. If you prefer some other templating\nsystem, then you will have to write a TemplateSystem plugin. Here's how they work.\nFirst, you have to create a .plugin file. Here's the one for the Mako plugin:</p>\n<pre class=\"code ini literal-block\">\n<span class=\"k\">[Core]</span>\n<span class=\"na\">Name</span> <span class=\"o\">=</span> <span class=\"s\">mako</span>\n<span class=\"na\">Module</span> <span class=\"o\">=</span> <span class=\"s\">mako</span>\n\n<span class=\"k\">[Documentation]</span>\n<span class=\"na\">Author</span> <span class=\"o\">=</span> <span class=\"s\">Roberto Alsina</span>\n<span class=\"na\">Version</span> <span class=\"o\">=</span> <span class=\"s\">0.1</span>\n<span class=\"na\">Website</span> <span class=\"o\">=</span> <span class=\"s\">http://getnikola.com</span>\n<span class=\"na\">Description</span> <span class=\"o\">=</span> <span class=\"s\">Support for Mako templates.</span>\n</pre>\n<div class=\"note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">If you want to publish your plugin on the Plugin Index, <a class=\"reference external\" href=\"https://github.com/getnikola/plugins/blob/master/README.md\">read\nthe docs for the Index</a>\n(and the .plugin file examples and explanations).</p>\n</div>\n<p>You will have to replace \"mako\" with your template system's name, and other data\nin the obvious ways.</p>\n<p>The \"Module\" option is the name of the module, which has to look something like this,\na stub for a hypothetical system called \"Templater\":</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span> <span class=\"nn\">nikola.plugin_categories</span> <span class=\"kn\">import</span> <span class=\"n\">TemplateSystem</span>\n\n<span class=\"c\"># You have to inherit TemplateSystem</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">TemplaterTemplates</span><span class=\"p\">(</span><span class=\"n\">TemplateSystem</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Wrapper for Templater templates.\"\"\"</span>\n\n    <span class=\"c\"># name has to match Name in the .plugin file</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"templater\"</span>\n\n    <span class=\"c\"># You *must* implement this, even if to return []</span>\n    <span class=\"c\"># It should return a list of all the files that,</span>\n    <span class=\"c\"># when changed, may affect the template's output.</span>\n    <span class=\"c\"># usually this involves template inheritance and</span>\n    <span class=\"c\"># inclusion.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_deps</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">[]</span>\n\n    <span class=\"c\"># A list of directories where the templates will be</span>\n    <span class=\"c\"># located. Most template systems have some sort of</span>\n    <span class=\"c\"># template loading tool that can use this.</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set_directories</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">directories</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Create a template lookup.\"\"\"</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"c\"># The method that does the actual rendering.</span>\n    <span class=\"c\"># template_name is the name of the template file,</span>\n    <span class=\"c\"># output_name is the file for the output, context</span>\n    <span class=\"c\"># is a dictionary containing the data the template</span>\n    <span class=\"c\"># uses for rendering.</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">render_template</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">template_name</span><span class=\"p\">,</span> <span class=\"n\">output_name</span><span class=\"p\">,</span>\n        <span class=\"n\">context</span><span class=\"p\">,</span> <span class=\"n\">global_context</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Render the template into output_name using context.\"\"\"</span>\n        <span class=\"k\">pass</span>\n</pre>\n</div>\n<div class=\"section\" id=\"task-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id4\">Task Plugins</a></h3>\n<p>If you want to do something that depends on the data in your site, you\nprobably want to do a Task plugin, which will make it be part of the\n<tt class=\"docutils literal\">nikola build</tt> command. There are the currently available tasks, all\nprovided by plugins:</p>\n<div class=\"sidebar\">\n<p class=\"first sidebar-title\">Other Tasks</p>\n<p class=\"last\">There are also <tt class=\"docutils literal\">LateTask</tt> plugins, which are executed later,\nand <tt class=\"docutils literal\">TaskMultiplier</tt> plugins that take a task and create\nmore tasks out of it.</p>\n</div>\n<pre class=\"literal-block\">\n$ nikola list\nScanning posts....done!\nbuild_bundles\nbuild_less\ncopy_assets\ncopy_files\npost_render\nredirect\nrender_archive\nrender_galleries\nrender_galleries_clean\nrender_indexes\nrender_listings\nrender_pages\nrender_posts\nrender_rss\nrender_site\nrender_sources\nrender_tags\nsitemap\n</pre>\n<p>These have access to the <tt class=\"docutils literal\">site</tt> object which contains your timeline and\nyour configuration.</p>\n<p>The critical bit of Task plugins is their <tt class=\"docutils literal\">gen_tasks</tt> method, which <tt class=\"docutils literal\">yields</tt>\n<a class=\"reference external\" href=\"http://pydoit.org/tasks.html\">doit tasks</a>.</p>\n<p>The details of how to handle dependencies, etc., are a bit too much for this\ndocument, so I'll just leave you with an example, the <tt class=\"docutils literal\">copy_assets</tt> task.\nFirst the <tt class=\"docutils literal\">task_copy_assets.plugin</tt> file, which you should copy and edit\nin the logical ways:</p>\n<pre class=\"code ini literal-block\">\n<span class=\"k\">[Core]</span>\n<span class=\"na\">Name</span> <span class=\"o\">=</span> <span class=\"s\">copy_assets</span>\n<span class=\"na\">Module</span> <span class=\"o\">=</span> <span class=\"s\">task_copy_assets</span>\n\n<span class=\"k\">[Documentation]</span>\n<span class=\"na\">Author</span> <span class=\"o\">=</span> <span class=\"s\">Roberto Alsina</span>\n<span class=\"na\">Version</span> <span class=\"o\">=</span> <span class=\"s\">0.1</span>\n<span class=\"na\">Website</span> <span class=\"o\">=</span> <span class=\"s\">http://getnikola.com</span>\n<span class=\"na\">Description</span> <span class=\"o\">=</span> <span class=\"s\">Copy theme assets into output.</span>\n</pre>\n<div class=\"note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">If you want to publish your plugin on the Plugin Index, <a class=\"reference external\" href=\"https://github.com/getnikola/plugins/blob/master/README.md\">read\nthe docs for the Index</a>\n(and the .plugin file examples and explanations).</p>\n</div>\n<p>And the <tt class=\"docutils literal\">task_copy_assets.py</tt> file, in its entirety:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">nikola.plugin_categories</span> <span class=\"kn\">import</span> <span class=\"n\">Task</span>\n<span class=\"kn\">from</span> <span class=\"nn\">nikola</span> <span class=\"kn\">import</span> <span class=\"n\">utils</span>\n\n<span class=\"c\"># Have to inherit Task to be a task plugin</span>\n<span class=\"k\">class</span> <span class=\"nc\">CopyAssets</span><span class=\"p\">(</span><span class=\"n\">Task</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Copy theme assets into output.\"\"\"</span>\n\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"copy_assets\"</span>\n\n    <span class=\"c\"># This yields the tasks</span>\n    <span class=\"k\">def</span> <span class=\"nf\">gen_tasks</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Create tasks to copy the assets of the whole theme chain.\n\n        If a file is present on two themes, use the version\n        from the \"youngest\" theme.\n        \"\"\"</span>\n\n        <span class=\"c\"># I put all the configurations and data the plugin uses</span>\n        <span class=\"c\"># in a dictionary because utils.config_changed will</span>\n        <span class=\"c\"># make it so that if these change, this task will be</span>\n        <span class=\"c\"># marked out of date, and run again.</span>\n\n        <span class=\"n\">kw</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s\">\"themes\"</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">THEMES</span><span class=\"p\">,</span>\n            <span class=\"s\">\"output_folder\"</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'OUTPUT_FOLDER'</span><span class=\"p\">],</span>\n            <span class=\"s\">\"filters\"</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'FILTERS'</span><span class=\"p\">],</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">theme_name</span> <span class=\"ow\">in</span> <span class=\"n\">kw</span><span class=\"p\">[</span><span class=\"s\">'themes'</span><span class=\"p\">]:</span>\n            <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">get_theme_path</span><span class=\"p\">(</span><span class=\"n\">theme_name</span><span class=\"p\">),</span> <span class=\"s\">'assets'</span><span class=\"p\">)</span>\n            <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">kw</span><span class=\"p\">[</span><span class=\"s\">'output_folder'</span><span class=\"p\">],</span> <span class=\"s\">'assets'</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">task</span> <span class=\"ow\">in</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">copy_tree</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">task</span><span class=\"p\">[</span><span class=\"s\">'name'</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">tasks</span><span class=\"p\">:</span>\n                    <span class=\"k\">continue</span>\n                <span class=\"n\">tasks</span><span class=\"p\">[</span><span class=\"n\">task</span><span class=\"p\">[</span><span class=\"s\">'name'</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">task</span>\n                <span class=\"n\">task</span><span class=\"p\">[</span><span class=\"s\">'uptodate'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'uptodate'</span><span class=\"p\">,</span> <span class=\"p\">[])</span> <span class=\"o\">+</span> \\\n                    <span class=\"p\">[</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">config_changed</span><span class=\"p\">(</span><span class=\"n\">kw</span><span class=\"p\">)]</span>\n                <span class=\"n\">task</span><span class=\"p\">[</span><span class=\"s\">'basename'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span>\n                <span class=\"c\"># If your task generates files, please do this.</span>\n                <span class=\"k\">yield</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">apply_filters</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">,</span> <span class=\"n\">kw</span><span class=\"p\">[</span><span class=\"s\">'filters'</span><span class=\"p\">])</span>\n</pre>\n</div>\n<div class=\"section\" id=\"pagecompiler-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id5\">PageCompiler Plugins</a></h3>\n<p>These plugins implement markup languages, they take sources for posts or pages and\ncreate HTML or other output files. A good example is the <tt class=\"docutils literal\">misaka</tt> plugin.</p>\n<p>They must provide:</p>\n<dl class=\"docutils\">\n<dt><tt class=\"docutils literal\">compile_html</tt></dt>\n<dd>Function that builds a file.</dd>\n<dt><tt class=\"docutils literal\">create_post</tt></dt>\n<dd>Function that creates an empty file with some metadata in it.</dd>\n</dl>\n<p>If the compiler produces something other than HTML files, it should also implement <tt class=\"docutils literal\">extension</tt> which\nreturns the preferred extension for the output file.</p>\n</div>\n<div class=\"section\" id=\"restextension-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id6\">RestExtension Plugins</a></h3>\n<p>Implement directives for reStructuredText, see <tt class=\"docutils literal\">media.py</tt> for a simple example.</p>\n</div>\n<div class=\"section\" id=\"markdownextension-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id7\">MarkdownExtension Plugins</a></h3>\n<p>Implement Markdown extensions, see <tt class=\"docutils literal\">mdx_nikola.py</tt> for a simple example.</p>\n</div>\n<div class=\"section\" id=\"signalhandler-plugins\">\n<h3><a class=\"toc-backref\" href=\"/stories/extending.html#id8\">SignalHandler Plugins</a></h3>\n<p>These plugins extend the <tt class=\"docutils literal\">SignalHandler</tt> class and connect to one or more\nsignals via <a class=\"reference external\" href=\"http://pythonhosted.org/blinker/\">blinker</a>.</p>\n<p>The easiest way to do this is to reimplement <tt class=\"docutils literal\">set_site()</tt> and just connect to\nwhatever signals you want there.</p>\n<p>Currently Nikola emits the following signals:</p>\n<dl class=\"docutils\">\n<dt><tt class=\"docutils literal\">sighandlers_loaded</tt></dt>\n<dd>Right after SignalHandler plugin activation.</dd>\n<dt><tt class=\"docutils literal\">initialized</tt></dt>\n<dd>When all tasks are loaded.</dd>\n<dt><tt class=\"docutils literal\">configured</tt></dt>\n<dd>When all the configuration file is processed. Note that plugins are activated before this is emitted.</dd>\n<dt><tt class=\"docutils literal\">scanned</tt></dt>\n<dd>After posts are scanned.</dd>\n<dt><tt class=\"docutils literal\">new_post</tt></dt>\n<dd>When a new post is created, using the <tt class=\"docutils literal\">nikola new_post</tt> command.  The signal\ndata contains the path of the file, and the metadata file (if there is one).</dd>\n<dt><tt class=\"docutils literal\">deployed</tt></dt>\n<dd><p class=\"first\">When the <tt class=\"docutils literal\">nikola deploy</tt> command is run, and there is at least one new\nentry/post since <tt class=\"docutils literal\">last_deploy</tt>.  The signal data is of the form:</p>\n<pre class=\"last literal-block\">\n{\n 'last_deploy: # datetime object for the last deployed time,\n 'new_deploy': # datetime object for the current deployed time,\n 'clean': # whether there was a record of a last deployment,\n 'deployed': # all files deployed after the last deploy,\n 'undeployed': # all files not deployed since they are either future posts/drafts\n}\n</pre>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"section\" id=\"plugin-index\">\n<h2><a class=\"toc-backref\" href=\"/stories/extending.html#id9\">Plugin Index</a></h2>\n<p>There is a <a class=\"reference external\" href=\"http://plugins.getnikola.com/\">plugin index</a>, which stores all\nof the plugins for Nikola people wanted to share with the world.</p>\n<p>You may want to read the <a class=\"reference external\" href=\"https://github.com/getnikola/plugins/blob/master/README.md\">README for the Index</a> if you want to\npublish your package there.</p>\n</div>\n<div class=\"section\" id=\"path-link-resolution-mechanism\">\n<h2><a class=\"toc-backref\" href=\"/stories/extending.html#id10\">Path/Link Resolution Mechanism</a></h2>\n<p>Any plugin can register a function using <tt class=\"docutils literal\">Nikola.register_path_handler</tt> to\nallow resolution of paths and links. These are useful for templates, which\ncan access them via _link.</p>\n<p>For example, you can always get a link to the path for the feed of the \"foo\" tag\nby using <tt class=\"docutils literal\"><span class=\"pre\">_link('tag_rss',</span> 'foo')</tt> or the <tt class=\"docutils literal\"><span class=\"pre\">link://tag_rss/foo</span></tt> URL.</p>\n<p>Here's the relevant code from the tag plugin.</p>\n<pre class=\"code python literal-block\">\n<span class=\"c\"># In set_site</span>\n<span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">register_path_handler</span><span class=\"p\">(</span><span class=\"s\">'tag_rss'</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tag_rss_path</span><span class=\"p\">)</span>\n\n<span class=\"c\"># And these always take name and lang as arguments and returl a list of</span>\n<span class=\"c\"># path elements.</span>\n<span class=\"k\">def</span> <span class=\"nf\">tag_rss_path</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">lang</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">_f</span> <span class=\"k\">for</span> <span class=\"n\">_f</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'TRANSLATIONS'</span><span class=\"p\">][</span><span class=\"n\">lang</span><span class=\"p\">],</span>\n                          <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'TAG_PATH'</span><span class=\"p\">],</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">slugify_name</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s\">\".xml\"</span><span class=\"p\">]</span> <span class=\"k\">if</span>\n            <span class=\"n\">_f</span><span class=\"p\">]</span>\n</pre>\n</div>\n<div class=\"section\" id=\"template-hooks\">\n<h2><a class=\"toc-backref\" href=\"/stories/extending.html#id11\">Template Hooks</a></h2>\n<p>Plugins can use a hook system for adding stuff into templates.  In order to use\nit, a plugin must register itself.  The following hooks currently exist:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\">extra_head</tt> (not equal to the config option!)</li>\n<li><tt class=\"docutils literal\">body_end</tt> (not equal to the config option!)</li>\n<li><tt class=\"docutils literal\">page_header</tt></li>\n<li><tt class=\"docutils literal\">menu</tt></li>\n<li><tt class=\"docutils literal\">menu_alt</tt> (right-side menu in bootstrap, after <tt class=\"docutils literal\">menu</tt> in base)</li>\n<li><tt class=\"docutils literal\">page_footer</tt></li>\n</ul>\n<p>For example, in order to register a script into <tt class=\"docutils literal\">extra_head</tt>:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c\"># In set_site</span>\n<span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">template_hooks</span><span class=\"p\">[</span><span class=\"s\">'extra_head'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s\">'&lt;script src=\"/assets/js/fancyplugin.js\"&gt;'</span><span class=\"p\">)</span>\n</pre>\n<p>There is also another API available.  It allows use of dynamically generated\nHTML:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c\"># In set_site</span>\n<span class=\"k\">def</span> <span class=\"nf\">generate_html_bit</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">ftype</span><span class=\"o\">=</span><span class=\"s\">'js'</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s\">'&lt;script src=\"/assets/{t}/{n}.{t}\"&gt;'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"n\">ftype</span><span class=\"p\">)</span>\n\n<span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">template_hooks</span><span class=\"p\">[</span><span class=\"s\">'extra_head'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">generate_html_bit</span><span class=\"p\">,</span> <span class=\"bp\">False</span><span class=\"p\">,</span> <span class=\"s\">'fancyplugin'</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"s\">'js'</span><span class=\"p\">)</span>\n</pre>\n<p>The second argument to <tt class=\"docutils literal\">append()</tt> is used to determine whether the function\nneeds access to the current template context and the site.  If it it set to\n<tt class=\"docutils literal\">True</tt>, the function will also receive <tt class=\"docutils literal\">site</tt> and <tt class=\"docutils literal\">context</tt> keyword\narguments.  Example use:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c\"># In set_site</span>\n<span class=\"k\">def</span> <span class=\"nf\">greeting</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"n\">endswith</span><span class=\"o\">=</span><span class=\"s\">''</span><span class=\"p\">,</span> <span class=\"n\">site</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"s\">'lang'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s\">'en'</span><span class=\"p\">:</span>\n        <span class=\"n\">greet</span> <span class=\"o\">=</span> <span class=\"s\">u'Hello'</span>\n    <span class=\"k\">elif</span> <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"s\">'lang'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s\">'es'</span><span class=\"p\">:</span>\n        <span class=\"n\">greet</span> <span class=\"o\">=</span> <span class=\"s\">u'¡Hola'</span>\n\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"s\">u' BLOG_TITLE = {0}'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s\">'BLOG_TITLE'</span><span class=\"p\">](</span><span class=\"n\">context</span><span class=\"p\">[</span><span class=\"s\">'lang'</span><span class=\"p\">]))</span>\n\n    <span class=\"k\">return</span> <span class=\"s\">u'&lt;h3&gt;{greet} {addr}{endswith}&lt;/h3&gt;'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">greet</span><span class=\"o\">=</span><span class=\"n\">greet</span><span class=\"p\">,</span> <span class=\"n\">addr</span><span class=\"o\">=</span><span class=\"n\">addr</span><span class=\"p\">,</span>\n    <span class=\"n\">endswith</span><span class=\"o\">=</span><span class=\"n\">endswith</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">t</span>\n\n<span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">template_hooks</span><span class=\"p\">[</span><span class=\"s\">'page_header'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">greeting</span><span class=\"p\">,</span> <span class=\"bp\">True</span><span class=\"p\">,</span> <span class=\"s\">u'Nikola Tesla'</span><span class=\"p\">,</span> <span class=\"n\">endswith</span><span class=\"o\">=</span><span class=\"s\">u'!'</span><span class=\"p\">)</span>\n</pre>\n</div></div>", "iso_date": "2012-03-30T23:00:00-03:00", "sourcelink": "/stories/extending.txt", "date": "2012-03-30T23:00:00", "text_teaser": null, "tags": [], "is_draft": false, "next_post": null, "is_private": false}, "id": "stories/extending.html.json"}