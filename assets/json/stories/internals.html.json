{"lang": "en", "permalink": "/stories/internals.html", "description": "", "title": "Nikola Internals", "template_name": "story.tmpl", "enable_comments": false, "post": {"prev_post": null, "permalink": "/stories/internals.html", "id_comments": "cache/stories/internals.html", "text_stripped": "When trying to guide someone into adding a feature in Nikola, it hit me that\nwhile the way it's structured makes sense to me it is far from obvious.\nSo, this is a short document explaining what each piece of Nikola does and\nhow it all fits together.\n\nNikola is a Pile of Plugins\nMost of Nikola is implemented as plugins using Yapsy.\nYou can ignore that they are plugins and just think of them as regular python\nmodules and packages with a funny little .plugin file next to them.\nSo, 90% of the time, what you want to do is either write a new plugin or extend\nan existing one.\nThere are several kinds of plugins, all implementing interfaces defined in\nnikola/plugin_categories.py and documented in\nExtending Nikola\nIf your plugin has a dependency, please make sure it doesn't make Nikola\nthrow an exception when the dependency is missing. Try to fail gracefully\nwith an informative message.\n\nCommands are plugins\nWhen you use nikola foo you are using the plugin command/foo. Those are\nused to extend Nikola's command line. Their interface is defined in the Command\nclass. They take options and arguments and do whatever you want, so go wild.\nThe build command is special\nThe build command triggers a whole lot of things, and is the core of Nikola\nbecause it's the one that you use to build sites. So it deserves its own section.\n\n\nThe Build Command\nNikola's goal is similar, deep at heart, to a Makefile. Take sources, compile them\ninto something, in this case a website. Instead of a Makefile, Nikola uses\ndoit\nDoit has the concept of \"tasks\". The 1 minute summary of tasks is that they have:\n\nactions\nWhat the task does. For example, convert a markdown document into HTML.\ndependencies\nIf this file changes, then we need to redo the actions. If this configuration\noption changes, redo it, etc.\ntargets\nFiles that the action generates. No two actions can have the same targets.\nbasename:name\nEach task is identified by either a name or a basename:name pair.\n\n\nMore about tasks\nIf you ever want to do your own tasks, you really should read the doit\ndocumentation on tasks\n\nSo, what Nikola does, when you use the build command, is to read the\nconfiguration conf.py from the current folder, instantiate\nthe Nikola class, and have it generate a whole list of tasks for doit\nto process. Then doit will decide which tasks need doing, and do them, in\nthe right order.\nThe place where the tasks are generated is in Nikola.gen_tasks, which collects tasks\nfrom all the plugins inheriting BaseTask, massages them a bit, then passes them\nto doit.\nSo, if you want things to happen on build you want to create a Task plugin, or extend\none of the existing ones.\n\nTests\nWhile Nikola is not a hardcore TDD project, we like tests. So, please add them if you can.\nYou can do doctests, you can do unit tests, you can do integration tests. There is support\nfor all of them.\n\n\n\nPosts and Stories\nNikola has a concept of posts and stories. Both are more or less the same thing, except\nposts are added into RSS feeds and stories are not. All of them are in a list called\n\"the timeline\" formed by objects of class Post.\nWhen you are creating a task that needs the list of posts and/or stories (for example,\nthe RSS creation plugin), your plugin should call self.site.scan_posts() to ensure\nthe timeline is created and available in self.site.timeline. You should not modify\nthe timeline, because it will cause consistency issues.\n\nscan_posts\nThe scan_posts function is what reads your site and creates the timeline.\nI am considering moving scan_posts off the core and into its own plugin\nso it can be replaced (for example, by a version that reads a database\ninstead of scanning a folder tree).\n\nYour plugin can use the timeline to generate \"stuff\" (technical term). For example,\nNikola comes with plugins that use the timeline to create a website (surprised?).\nThe workflow included with nikola is as follows (incomplete!):\n\nThe post is assigned a compiler based on its extension and the COMPILERS option.\nThe compiler is applied to the post data and a \"HTML fragment\" is produced. That\nfragment is stored in a cache (the posts plugin).\nThe configured theme has templates (and a template engine), which are applied to the post's\nHTML fragment and metadata (the pages plugin).\nThe original sources for the post are copied to some accessible place (the sources plugin).\nIf the post is tagged, some pages and RSS feeds for each tag are updated (the tags plugin).\nIf the post is new, it's included in the blog's RSS feed (the rss plugin).\nThe post is added in the right place in the index pages for the blog (the indexes plugin).\nCSS/JS/Images for the theme are put in the right places (the copy_assets and bundles plugins).\nA File describing the whole site is created (the sitemap plugin).\n\nYou can add whatever you want to that list: just create a plugin for it.\nYou can also expand Nikola's capabilities at several points:\n\ncompilers\nNikola supports a variety of markups. If you want to add another one, you need to create\na Compiler plugin.\ntemplates\nNikola's themes can use Jinja2 or Mako templates. If you prefer another template system,\nyou have to create a TemplateSystem plugin.\nthemes\nTo change how the generated site looks, you can create custom themes.\n\nAnd of course, you can also replace or extend each of the existing plugins.", "abs_permalink": "http://getnikola.com/stories/internals.html", "formatted_date": "2012-03-30 23:00", "enable_comments": false, "author": "Nikola Tesla", "use_in_feeds": false, "translated_to": [], "is_mathjax": false, "meta": {"description": "", "tags": "", "title": "Nikola Internals", "annotations": "", "keywords": "", "author": "", "template": "", "date": "2012-03-30 23:00:00 UTC-03:00", "password": "", "type": "text", "slug": "internals"}, "text": "<div><p class=\"lead\">When trying to guide someone into adding a feature in Nikola, it hit me that\nwhile the way it's structured makes sense <strong>to me</strong> it is far from obvious.</p>\n<p>So, this is a short document explaining what each piece of Nikola does and\nhow it all fits together.</p>\n<dl class=\"docutils\">\n<dt>Nikola is a Pile of Plugins</dt>\n<dd><p class=\"first\">Most of Nikola is implemented as plugins using <a class=\"reference external\" href=\"http://yapsy.sourceforge.net/\">Yapsy</a>.\nYou can ignore that they are plugins and just think of them as regular python\nmodules and packages with a funny little <tt class=\"docutils literal\">.plugin</tt> file next to them.</p>\n<p>So, 90% of the time, what you want to do is either write a new plugin or extend\nan existing one.</p>\n<p>There are several kinds of plugins, all implementing interfaces defined in\n<tt class=\"docutils literal\">nikola/plugin_categories.py</tt> and documented in\n<a class=\"reference external\" href=\"http://getnikola.com/extending.html\">Extending Nikola</a></p>\n<p class=\"last\">If your plugin has a dependency, please make sure it doesn't make Nikola\nthrow an exception when the dependency is missing. Try to fail gracefully\nwith an informative message.</p>\n</dd>\n<dt>Commands are plugins</dt>\n<dd>When you use <tt class=\"docutils literal\">nikola foo</tt> you are using the plugin <tt class=\"docutils literal\">command/foo</tt>. Those are\nused to extend Nikola's command line. Their interface is defined in the <tt class=\"docutils literal\">Command</tt>\nclass. They take options and arguments and do whatever you want, so go wild.</dd>\n<dt>The <tt class=\"docutils literal\">build</tt> command is special</dt>\n<dd>The <tt class=\"docutils literal\">build</tt> command triggers a whole lot of things, and is the core of Nikola\nbecause it's the one that you use to build sites. So it deserves its own section.</dd>\n</dl>\n<div class=\"section\" id=\"the-build-command\">\n<h2>The Build Command</h2>\n<p>Nikola's goal is similar, deep at heart, to a Makefile. Take sources, compile them\ninto something, in this case a website. Instead of a Makefile, Nikola uses\n<a class=\"reference external\" href=\"http://pydoit.org\">doit</a></p>\n<p>Doit has the concept of \"tasks\". The 1 minute summary of tasks is that they have:</p>\n<dl class=\"docutils\">\n<dt>actions</dt>\n<dd>What the task <strong>does</strong>. For example, convert a markdown document into HTML.</dd>\n<dt>dependencies</dt>\n<dd>If this file changes, then we need to redo the actions. If this configuration\noption changes, redo it, etc.</dd>\n<dt>targets</dt>\n<dd>Files that the action generates. No two actions can have the same targets.</dd>\n<dt>basename:name</dt>\n<dd>Each task is identified by either a name or a basename:name pair.</dd>\n</dl>\n<div class=\"sidebar\">\n<p class=\"first sidebar-title\">More about tasks</p>\n<p class=\"last\">If you ever want to do your own tasks, you really should read the doit\n<a class=\"reference external\" href=\"http://pydoit.org/tasks.html\">documentation on tasks</a></p>\n</div>\n<p>So, what Nikola does, when you use the build command, is to read the\nconfiguration <tt class=\"docutils literal\">conf.py</tt> from the current folder, instantiate\nthe <tt class=\"docutils literal\">Nikola</tt> class, and have it generate a whole list of tasks for doit\nto process. Then doit will decide which tasks need doing, and do them, in\nthe right order.</p>\n<p>The place where the tasks are generated is in <tt class=\"docutils literal\">Nikola.gen_tasks</tt>, which collects tasks\nfrom all the plugins inheriting <tt class=\"docutils literal\">BaseTask</tt>, massages them a bit, then passes them\nto doit.</p>\n<p>So, if you want things to happen on <tt class=\"docutils literal\">build</tt> you want to create a Task plugin, or extend\none of the existing ones.</p>\n<div class=\"sidebar\">\n<p class=\"first sidebar-title\">Tests</p>\n<p class=\"last\">While Nikola is not a hardcore TDD project, we like tests. So, please add them if you can.\nYou can do doctests, you can do unit tests, you can do integration tests. There is support\nfor all of them.</p>\n</div>\n</div>\n<div class=\"section\" id=\"posts-and-stories\">\n<h2>Posts and Stories</h2>\n<p>Nikola has a concept of posts and stories. Both are more or less the same thing, except\nposts are added into RSS feeds and stories are not. All of them are in a list called\n\"the timeline\" formed by objects of class <tt class=\"docutils literal\">Post</tt>.</p>\n<p>When you are creating a task that needs the list of posts and/or stories (for example,\nthe RSS creation plugin), your plugin should call <tt class=\"docutils literal\">self.site.scan_posts()</tt> to ensure\nthe timeline is created and available in <tt class=\"docutils literal\">self.site.timeline</tt>. You should not modify\nthe timeline, because it will cause consistency issues.</p>\n<div class=\"sidebar\">\n<p class=\"first sidebar-title\">scan_posts</p>\n<p>The scan_posts function is what reads your site and creates the timeline.</p>\n<p class=\"last\">I am considering moving scan_posts off the core and into its own plugin\nso it can be replaced (for example, by a version that reads a database\ninstead of scanning a folder tree).</p>\n</div>\n<p>Your plugin can use the timeline to generate \"stuff\" (technical term). For example,\nNikola comes with plugins that use the timeline to create a website (surprised?).</p>\n<p>The workflow included with nikola is as follows (incomplete!):</p>\n<ol class=\"arabic simple\">\n<li>The post is assigned a compiler based on its extension and the <tt class=\"docutils literal\">COMPILERS</tt> option.</li>\n<li>The compiler is applied to the post data and a \"HTML fragment\" is produced. That\nfragment is stored in a cache (the <tt class=\"docutils literal\">posts</tt> plugin).</li>\n<li>The configured theme has templates (and a template engine), which are applied to the post's\nHTML fragment and metadata (the <tt class=\"docutils literal\">pages</tt> plugin).</li>\n<li>The original sources for the post are copied to some accessible place (the <tt class=\"docutils literal\">sources</tt> plugin).</li>\n<li>If the post is tagged, some pages and RSS feeds for each tag are updated (the <tt class=\"docutils literal\">tags</tt> plugin).</li>\n<li>If the post is new, it's included in the blog's RSS feed (the <tt class=\"docutils literal\">rss</tt> plugin).</li>\n<li>The post is added in the right place in the index pages for the blog (the <tt class=\"docutils literal\">indexes</tt> plugin).</li>\n<li>CSS/JS/Images for the theme are put in the right places (the <tt class=\"docutils literal\">copy_assets</tt> and <tt class=\"docutils literal\">bundles</tt> plugins).</li>\n<li>A File describing the whole site is created (the <tt class=\"docutils literal\">sitemap</tt> plugin).</li>\n</ol>\n<p>You can add whatever you want to that list: just create a plugin for it.</p>\n<p>You can also expand Nikola's capabilities at several points:</p>\n<dl class=\"docutils\">\n<dt>compilers</dt>\n<dd>Nikola supports a variety of markups. If you want to add another one, you need to create\na <tt class=\"docutils literal\">Compiler</tt> plugin.</dd>\n<dt>templates</dt>\n<dd>Nikola's themes can use Jinja2 or Mako templates. If you prefer another template system,\nyou have to create a <tt class=\"docutils literal\">TemplateSystem</tt> plugin.</dd>\n<dt>themes</dt>\n<dd>To change how the generated site looks, you can create custom themes.</dd>\n</dl>\n<p>And of course, you can also replace or extend each of the existing plugins.</p>\n</div></div>", "iso_date": "2012-03-30T23:00:00-03:00", "sourcelink": "/stories/internals.txt", "date": "2012-03-30T23:00:00", "text_teaser": null, "tags": [], "is_draft": false, "next_post": null, "is_private": false}, "id": "stories/internals.html.json"}